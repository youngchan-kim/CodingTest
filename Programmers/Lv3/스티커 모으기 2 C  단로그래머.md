문제

<https://school.programmers.co.kr/learn/courses/30/lessons/12971>

[프로그래머스

코드 중심의 개발자 채용. 스택 기반의 포지션 매칭. 프로그래머스의 개발자 맞춤형 프로필을 등록하고, 나와 기술 궁합이 잘 맞는 기업들을 매칭 받으세요.

programmers.co.kr](https://school.programmers.co.kr/learn/courses/30/lessons/12971)

사용된 알고리즘

DP 동적 프로그래밍 (다이나믹 프로그래밍)

* 어떤 공식이나 특정 형태가 아닌 방법론에 가까운 개념으로써의 알고리즘이다.
* 이론적으로 DP를 이해하기는 쉽지만, 문제에 적용하기 어렵다.

**DP에 대해 대부분이렇게 표현한다.**

* 하나의 큰 문제를 작은 문제로 나누고, 그 작은 문제를 해결하여 큰 문제의 답을 도출해 내는 기법
* 작은 문제를 해결하는 과정에서 중복되는 연산을 수행하지 않는 기법

**접근 방식**

1 규칙 큰 문제를 작은 문제로 표현할 수 있다.

더보기

피보나치의 경우

f(3) = f(2)+  f(1)

f(4) = f(3)+ f(2)

f(5) = f(4)+ f(3)

f(6) = f(5)+ f(4)

설명

더보기

문제에서 원하는 답은 F(7)의 값이 얼마인지 알고 싶은 겁니다.

1 조건  F(7)의 값을 구하기 위해서는 보다 하위의 값에서 일정한 규칙을 찾아야 합니다.

2 조건  하위의 값은 항상 값을 알 수 있어야합니다.

현재 가지고 있는 F(0), F(1), F(2), F(3) 값을 비교했을때, F(0)+F(1) =F(2) ,F(1)+F(2) =F(3)이라는 걸 알 수 있습니다.

이렇게 규칙을 찾았네요.

이 규칙을 모든 값에 적용하려면

 F(N) = F(N-2)+F(N-1)

이됩니다.

저는 바로 와닿지는 않더라구요. 저는 그렇게 느꼈습니다. 좀 멍청하거든요.

다른 예시입니다.

더보기

문제에서 원하는 것은 원형 스티커가 있는 데 스티커를 얻으면 양옆의 스티커는 훼손되어 얻을 수 없다는 예시입니다.

그렇다면

일단 스티커를 때면 양옆의 스티커를 얻을 수 없으니

F(1) = F(0)=false, F(2) =false가 되는 규칙을 알 수 있습니다.

만약에 F(0) = F(end)=false , F(1) =false가 되겠습니다.

즉 F(N) = F(N-1)=false , F(N+2)=false가 되겠죠

원형이기 때문입니다.

이경우 해당 조건을 만족하지만 2개의 조건을 더 뽑을 수 있습니다.

0번째 스티커를 제거한 경우

F(0) = F(end)=false , F(1) =false

1번째 스티커를 제거한 경우

F(1) = F(0)=false, F(2) =false

 로 두 조건에 따라 규칙을 적용한 것을 볼 수 있습니다.

 2 규칙 점화식

더보기

점화식은 공식이라고 말할 수 있습니다.

위에서 설명한

 F(N) = F(N-2)+F(N-1)

이것과

 F(N) = F(N-1)=false , F(N+2)=false라는 모든 F(N)에서 만족하는 식입니다.

3 규칙 Memoization(Optional)

더보기

Memoization은 프로그래밍시 동일한 계산을 중복 수행하는 경우 반복되는 동일한 연산 값을

메모리에 저장하여 중복 계산을 제거하는 것으로 프로그램의 속도를 빠르게 하는 기술, 방법론입니다.

캐싱입니다.

피보나치로 설명한다면

 F(N) = F(N-2)+F(N-1)는

F(2) = F(0)+F(1)

F(3) = F(1)+F(2)

로 표현 되는 데 지금 적은 식은 캐싱 되고 있는 것입니다.

캐싱되지 않은 피보나치식은 생각보다 간단합니다.

F(3) = F(1) +F(1) + F(0)

이렇게 사용되거든요

보면 F(1)이 두번 들어가고 연산자의 수가 2개로 늘어납니다.

연산을 2번하게 되는데 F(N)의 숫자가 커지면 커질 수록 기하급수적으로 늘어나는 연산를 볼 수 있게됩니다.

F(N)이라는 값에 도달하기 위해 중간에 도출할 수 있는 수를 저장하여 사용하는 아래의 방법은 캐싱이라고 볼 수 있습니다.

F(2) = F(0)+F(1)

F(3) = F(1)+F(2)

문제 풀다가

for(int i = 0; i < bigVector.size(); i++)

해당 반복문을 필요해 의해

for(int i = 0; i < bigVector.size(); i++)

for(int i = 0; i < bigVector.size(); i++)

for(int i = 0; i < bigVector.size(); i++)

여러번쓸때

연산은 아니지만 의미없는  size()함수의 사용을 줄임으로써 프로그램의 무게를 덜어내는 방식

int len = bigVector.size();

for(int i = 0; i < len  ; i++)

for(int i = 0; i < len  ; i++)

또한 캐싱이라고 할 수 있습니다.

Bottom-Up 과 Top-Down

DP는 모두 두가지의 방식으로 풀이된다.

Bottom-Up방식은

더보기

피보나치의 경우 가장 첫번째 숫자부터 차근차근 풀어내는 방법이다.

Top-Down방식

더보기

어떤 글을 읽고 내용을 설명해야 할때

주어진 글이 너무 길어서 각 문단의 앞부분만 읽고 전체적인 맥락을 이해하는 방식이다.

각 문단의 앞부분(TOP)을 읽어 전체 맥락(DOWN)를 파악

패턴을 이용하는 과정을 사용한다.

즉 재귀함수를 이용하여 답을 찾는 방식이다.

 둘다 피보나치로 설명하자면

더보기

Bottom\_Up

F(0), F(1)의 값을 알기 때문에 F(2)의 값을 도출할 수 있다.

단순 반복을 통하여 F(N)의 값을 얻으면된다.

이미  F(N-1)+F(N-2)의 방법을 알기 때문에

Top\_Down

F(N)의 값을 알기위해 F(N-1)+F(N-2)의 식을 찾는 방법이다.

f(n)부터 계산을 시작하면서 f(n)을 계산하기 위해 필요한 데이터를 구하는 것이다.

  ex) f(n)을 계산하기 위해서는 f(n -1)과 f(n - 2)를 알아야 한다.

### 이 설명이 아닌 경우 글 달아 주시면 고치도록하겠습니다.

### 제가 이해한 방식이라,

### 설명이 잘못되었다는 건 제가 잘못 이해했기 때문이라고 생각합니다.

문제 풀이 핵심

큰 조건 2가지

* 땔 수 있느 스티커가 없어질때까지 때야한다.
* 스티커는 원형으로 이어져있다.

작은 조건 2가지

* 0번째 스티커를 땐 경우
* 0번째 스티커를 때지 않은 경우

도출해야하는 값 모든 스티커를 땠을 때 가장 큰 값

* max함수가 사용된다.

내 코드

```
/*
원형 배열 무한히 반복되는 배열
하나를 뜯으면 양쪽은 훼손되어 뜯을 수 없다.

1조건 i번째를 뜯게 되면 dp[i-1], dp[i+1]은 훼손 되었음으로 뜯지 못한다.
2조건 짝수 인 경우 최대 얻을 수 있는 티켓의 수는 n/2 개이다.
3조건 홀수 인 경우 최대 찢을 수 있는 티켓의 수는 또한 n/2개이다.

4조건 예제 대로라면 무조건 적으로 첫번째 티켓을 뜯어서 나온 최대값과 두번째 티켓을 뜯어서 나온 최대값의 비교로 최댓값을 얻어낼 수 있다.

Sum이라는 배열이 있을때 Sum[a]=b는 a번째 스티커를 뜯었을때 얻을 수 있는 최대값을 의미
a번째 스티커를 뜨을 수 있는 최대값을 얻으려면 2가지 비교
a-2번째를 뜯은 경우 의 최대값과 +a번째를 뜯은 값
a번째를 뜯지 않고 a-1번째를 뜯어서 얻을 수 있는 최대값
2가지를 비교하면된다.

3번스티커까지의 최댓값은 
2번 스티커까지의 최대값과 1번스티커의 최대값과 3번스티커의 값을 합친값 중 큰 값이 3번 스티커까지의 최대값이다.

*/
#include <vector>
using namespace std;

int DP[100010];

int solution(vector<int> sticker)
{
    int answer = 0;
    int n = sticker.size();
    if (n == 1) return sticker[0];

    //0번째 스티커를 뜯은 경우
    //1번째 스티커의 최대값은 0번째 스티커의 값이다.
    //또한 n-1번째 즉 마지막 스티커는 최대값을 구할 수 없다.
    //훼손되어 있음
    DP[0] = sticker[0];
    DP[1] = sticker[0];

    for (int i = 2; i < n-1; i++)
    {
        DP[i] = max(DP[i - 2] + sticker[i], DP[i - 1]);
    }
    answer = max(DP[n - 1], DP[n - 2]);

    //0번째 스티커를 뜯지않은 경우
    //1번째 스티커의 값이 현 최대값이된다.
    //n-1번째 쯕 마지막 스티커의 최대값을 구할 수 있다.
    DP[0] = 0;
    DP[1] = sticker[1];

    for (int i = 2; i < n; i++)
    {
        DP[i] = max(DP[i - 2] + sticker[i], DP[i - 1]);
    }
    answer = max(answer,max(DP[n - 1], DP[n - 2]));
    return answer;
}

int main()
{ 
    solution({ 14, 6, 5, 11, 3, 9, 2, 10 });
    return 0;
}
```

I learned from the problem!

다이나믹 프로그래밍에 대해 한번 더 볼 수 있었다.

DP 문제인지 의심해야하는 경우

1. 이미 구하여 저장한 값들을 바탕으로 현재의 값을 구하는 점화식을 세울 수 있을 때
2. 최대값, 최소값 같은 최적해를 구해야 할 때
3. 모든 원소들 마다 그때 까지 선택한 최적해를 구할 수 있을 때
4. 입력 크기가 엄청 큰경우
5. 프로그래머스에서 효율성테스트를 하는 경우

다른 사람 코드

```
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

int d[100001];
int d2[100001];
vector<int> sticker2;
int solution(vector<int> sticker)
{
    int answer = 0;
    int i;
    int n = sticker.size();

    if (n == 1) return sticker[0];
    for (int i=1; i<n; i++) {
        sticker2.push_back(sticker[i]);
    }
    sticker2.push_back(sticker[0]);

    for (int j=0; j<n; j++) {
        i = j+1;
        if (i-2>=0) d[i] = d[i-2]+sticker[j];
        if (i-3>=0) d[i] = max(d[i],d[i-3]+sticker[j]);
    }
    for (int j=0; j<n; j++) {
        i = j+1;
        if (i-2>=0) d2[i] = d2[i-2]+sticker2[j];
        if (i-3>=0) d2[i] = max(d2[i],d2[i-3]+sticker2[j]);
    }
    for (i=1; i<=n; i++) {
        answer = max(answer, d[i]);
        answer = max(answer, d2[i]);
    }

    return answer;
}
```

사용된 알고리즘

**특징**