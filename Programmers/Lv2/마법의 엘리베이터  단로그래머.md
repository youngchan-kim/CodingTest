문제

<https://school.programmers.co.kr/learn/courses/30/lessons/148653>

문제 풀이 핵심

제일 큰 자릿 수 부터 하는 게 아니라 가장 작은 자릿 수부터 체크하는 것

1의 자리수만 체크 하면 테스트 케이스에 걸린다.

다음자릿수도 체크 해 줘야하는 조건이 필요하다.

내 코드

```
#include <string>
#include <vector>
#include <cmath>

using namespace std;

/// <summary>
/// -1 ,+1, -10 +10, -100, +100등의 10의 제곱의 형태의 정수가 적힌 버튼이 있음
/// 현재 있는 층 - 입력한 층 < 0 움직이지 않음
/// 버튼을 한번 누르는데 1개의 마석이 소모됨 최소한으로 소모하여 원하는 층으로 이동하는 할때 들어가는 마석의 갯수를 알아내는게 목표
/// 예시 16층에서 0층을 갈때 -1버튼 6개와 -10 버튼 한개면 갈 수있다 :  마석 7개 소모
/// 하지만 +1버튼 4개 -10버튼 2개 : 마석 6개 소모
/// 
/// 민수가 있는 층의 정보는 storey에 저장
/// 
/// 1 ≤ storey ≤ 100,000,000의 값을 가짐
/// 
/// 16인 경우
/// -10 :2개 +1 :4개
/// -10 :1개 -1 :6개
/// 15인 경우
/// -10 :2개 +1 :5개
/// -10 :1개 -1 :5개
/// 14인경우 
/// -10 :2개 +1 :6개
/// -10 :1개 -1 :4개
/// 
/// 반복문 
/// 1조건 5보다 작으면 있는 그대로 누르기
/// 2조건 1의 자리 수가 5초과일 때, 한자리 수 위 버튼 1번 누르고 10-n만큼 버튼 누리기
/// 3조건1의 자리수가 5일때, 다음 자리수가 5이상이면 2번 아니면 1번
/// </summary>
/// <param name="storey"></param>
/// <returns></returns>
int solution(int storey) {
    int answer = 0;
    int num = 0;
    while (storey)
    {
        num = storey % 10;
        storey /= 10;
        /// 1조건 5보다 작으면 있는 그대로 누르기

        if (num < 5)
        {
            answer += num;
        }
        /// 2조건 1의 자리 수가 5초과일 때, 한자리 수 위 버튼 1번 누르고 10-n만큼 버튼 누리기

        else if (num > 5)
        {
            ++storey;
            answer += 10 - num;
        }
        /// 3조건1의 자리수가 5일때, 다음 자리수가 5이상이면 2번 아니면 1번
        /// ex 65인 경우
        /// 1번 계산법
        /// 10자리 6번 1자리 5번 총 11번
        /// 2번 계산법
        /// 6이 5이상이므로 2번 계산 법인 65 -100으로  계산 +35 100자리 1번 10자리 3번 1자리 5번 총 9번
        /// ex 45인 경우
        /// 1번 계산법
        /// 10자리 4번 1자리 5번 총 9번
        /// 2번 계산법
        /// 4이 5미만이지만 2번 계산 법인 45 -100으로  계산 +55 100자리 1번 10자리 5번 1자리 5번 총 11번
        /// 65의 경우 2번 계산법이 효율적이고 45의 경우 1번 계산 법이 효율적이다.
        /// 차이는 다음수가 5이상이면 그 다다음 수를 증가시켜주면 해결됨
        else
        {
            int next_num = storey % 10;
            if (next_num >= 5)
            {
                ++storey;
            }
            answer += num;
        }
    }
    return answer;
}
```

무엇을 배웠나.

재귀함수로 풀이가 가능하다.

다른 사람 코드

```
#include<algorithm>

using namespace std;

int sol(int num) 
{
	//num이 10보다 작은 경우 num이 5보다 크면 -10을 한 값에 횟수를 1더해주는게 0을 만들었을때의 수가 적음 
    if(num < 10) return min(num, 10-num+1);
    //다음 수가 a는 5보다 작은 경우 b는 5보다 큰경우이다.
    int a = num % 10, b = 10 - num % 10;
    //ex num이 45와 65인경우 
    //45 (45-5 / 10) +5 =9, ((45+6)/10) +6 =11
    //(45-5 / 10) => (4<10) 4+5 =9
    //51/10 => 5+6 =11
    //65
    return min(sol((num-a)/10)+a, sol((num+b)/10)+b);
}

int solution(int storey) {
    return sol(storey);
}
```