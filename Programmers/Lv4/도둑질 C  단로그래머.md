다른 분들의 블로그에 올린 코드를 보면서 참고하여 풀었습니다.

사실 실력 키우기 위해 한 것이라 코드 자체는 다른 분들의 코드와 별 차이가 없습니다.

int DP1[1000001]를 전역 변수로 선언하는 이유는

더보기

지역 변수로 사용하면 1000001이라는 값이 너무 크기 때문에 스택 영역에서 오버플로우가 발생한다.

지역 변수은 스택영역을 사용한다.

전역 변수는 데이터영역을 사용한다.

스택 영역에서 감당할 수 있는 크기보다 데이터 영역에서 감당할 수 있는 크기가 크다

이유는 스택영역은 스택 알고리즘에 의하여 굴러가는데 컴파일 타임에 크기가 결정되기 때문에 무한히 할당 할 수 없다.

재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생한다.

전역변수/static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 바뀐다.

실행 중도에 전역변수가 변경 될 수도 있으니 이 영역은 Read-Write로 지정되어 있다.

즉. 크기가 결정되지 않는다.

내 코드

x번쨰 집을 털면 x-1,x+1번째 집은 털 수 없다 이유는 인접한 두집을 털면 경보가 울리기 때문   
서로 인접해 있기 때문에 0번쨰 집을 털면 마지막 집을 털 수 없다.   
두가지의 상황으로 나눌 수 있다   
1. 첫번째 집을 터는 경우   
2. 첫번째 집을 털지 않는 경우   
  
DP[]일차원 배열을 사용   
DP[a]=b의 의미는 a번째 집까지 털었을때 훔칠 수 있는 돈의 최대 액수는 b라는 뜻   
  
x번째 집을 터는 경우의 식은   
DP[x] 는 DP[x-2]의 집을 털었을때의 최대액수에 x번째 집을 털었을때 훔칠 수 있는 액수    
  
x번째 집을 털지 않는 경우의 식은   
x번째 집을 털지 않으면 x-1의 집을 털 었다는 이야기   
그렇다면 DP[x]= DP[x-1]의 식이 나온다.   
그러므로   
아래식이 나온다.   
DP[x] = max(DP[x-2]+monwy[x], DP[x-1])이된다.   
해당식은   
첫번째 집을 터는 경우와 아닌 경우로 나눈다면   
터는 경우에는 DP[0] = money[0]이 됨   
DP[0]을 털었기 때문에 DP[1]의 값은 DP[0]됨 서로 인접해있기 때문이다.

```
#include <string>
#include <vector>
int DP1[1000001];
int DP2[1000001];
using namespace std;

int solution(vector<int> money) {
    
    int n = money.size() - 1;
    DP1[0] = money[0];
    DP1[1] = DP1[0];
    DP2[0] = 0;
    DP2[1] = money[1];

    for (int i = 2; i < n; i++)
    {
        DP1[i] = max(DP1[i - 2] + money[i], DP1[i - 1]);
    }
    for (int i = 2; i <= n; i++)
    {
        DP2[i] = max(DP2[i - 2] + money[i], DP2[i - 1]);
    }
     return max(DP1[n-1],DP2[n]);
}
int main()
{
    solution({ 1, 2, 3, 1 });
    return 0;
}
```